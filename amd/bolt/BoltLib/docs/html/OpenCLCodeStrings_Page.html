<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Bolt Preview: Specifying OpenCL&trade; Code Strings : Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt Preview
   &#160;<span id="projectnumber">0.4.4</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Specifying OpenCL&trade; Code Strings : Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#SplitSource_Section">Introduction and the Split-Source Model</a></li>
<li class="level1"><a href="#Functors">C++ Functors</a></li>
<li class="level1"><a href="#OclSplitSource_Tools">Bolt Tools for Split-Source</a><ul><li class="level2"><a href="#boltfunctormacro">BOLT_FUNCTOR macro</a></li>
<li class="level2"><a href="#clCode_Traits">TypeName and ClCode Traits</a><ul><li class="level3"><a href="#TypeName"></a></li>
<li class="level3"><a href="#ClCode"></a></li>
</ul>
</li>
<li class="level2"><a href="#clCode_ReadingFromFile">Reading functors from a file</a></li>
<li class="level2"><a href="#clCode_Templates">Templated Classes</a></li>
</ul>
</li>
<li class="level1"><a href="#functorLanguage">Functor Language</a><ul><li class="level2"><a href="#different_code">Different Host and Device Code</a></li>
</ul>
</li>
<li class="level1"><a href="#Conclusion">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="SplitSource_Section"></a>
Introduction and the Split-Source Model</h1>
<p>OpenCL&trade; provides a split compilation model, meaning that the host and device code are split into separate compilation units and compiled by different compilers. In OpenCL&trade;, the device code (kernels) typically are provided as strings that are passed through the OpenCL&trade; runtime APIs to compile for the target device. A Bolt algorithm also can be executed on the CPU, and Bolt can use non-OpenCL&trade; paths for host execution, such as a serial loop, or a multi-core task-parallel runtime, such as Intel Threading Building Blocks. Also, advanced use cases of Bolt use a functor that is initialized on the host CPU using the functor ("function object") constructor, then executed on the device using the body operator. This page describes how to create functors for Bolt APIs so that the code is available to both the host C++ compiler and the OpenCL&trade; device compiler.</p>
<h1><a class="anchor" id="Functors"></a>
C++ Functors</h1>
<p>A functor is a C++ construct that lets developers construct a class or struct that can be called like a regular function. The surrounding class can capture additional values, which can be used inside the function, since the function receives a pointer to the class as one of its arguments. The function gains access to additional state beyond just its input arguments; this is provided without changing the calling signature of the function. This feature is a critical point for the construction of generic libraries (such as Bolt algorithms), which then can contain a call to the well-defined function interface.</p>
<p>For example, consider the classic Saxpy code, which uses a functor to pass the value "100" from the calling scope to the <code>transform</code> algorithm: <a class="anchor" id="saxpy_stl"></a> </p>
<div class="fragment"><div class="line"><span class="comment">// STL implementation of Saxpy showing using of functor:</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>SaxpyFunctor </div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> _a;</div>
<div class="line">    SaxpyFunctor(<span class="keywordtype">float</span> a) : _a(a) {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> operator() (<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;xx, <span class="keyword">const</span> <span class="keywordtype">float</span> &amp;yy)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> _a * xx + yy;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() { </div>
<div class="line">   SaxpyFunctor s(100);</div>
<div class="line"></div>
<div class="line">   std::vector&lt;float&gt; x(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; y(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; z(1000000);</div>
<div class="line">   </div>
<div class="line">   <a class="code" href="group__transform.html#ga7996624886b3d2bffe59f55fbbb81668">std::transform</a>(x.begin(), x.end(), y.begin(), z.begin(), s);</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="OclSplitSource_Tools"></a>
Bolt Tools for Split-Source</h1>
<p>Bolt requires that functor classes be defined both as strings (for OpenCL&trade; compilation) and as regular host-side definitions. Since we do not want to have to create and maintain two copies of our source code, Bolt provides several mechanisms to construct the two representations from a single source definition. These are described below.</p>
<h2><a class="anchor" id="boltfunctormacro"></a>
BOLT_FUNCTOR macro</h2>
<p>The simplest technique is to use the <a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> macro. Given a class name and a definition for that class, this macro automatically: </p>
<ul>
<li>Creates a string version of the class definition, and associates the string with the class. (Bolt </li>
<li>finds the string using a C++ trait called <code><a class="el" href="structClCode.html">ClCode</a></code>. This is described in more detail below.) </li>
<li>Create a string version of the class name. (Bolt finds the class name using the <code><a class="el" href="structTypeName.html">TypeName</a></code> </li>
<li>trait. This is described in more detail below in the section <a class="el" href="OpenCLCodeStrings_Page.html#clCode_Traits">TypeName and ClCode Traits</a>.) </li>
<li>The macro expansion also creates the class definition, so it is visible to the host compiler. This </li>
<li>lets the constructor be called from the host compiler.</li>
</ul>
<p>The example below shows how to use the <a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> macro to implement the Saxpy function using Bolt: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;bolt/cl/transform.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(SaxpyFunctor,</div>
<div class="line"><span class="keyword">struct</span> SaxpyFunctor </div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> _a;</div>
<div class="line">    SaxpyFunctor(<span class="keywordtype">float</span> a) : _a(a) {};</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> operator() (<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;xx, <span class="keyword">const</span> <span class="keywordtype">float</span> &amp;yy)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> _a * xx + yy;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() { </div>
<div class="line">   SaxpyFunctor s(100);</div>
<div class="line"></div>
<div class="line">   std::vector&lt;float&gt; x(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; y(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; z(1000000);</div>
<div class="line">   </div>
<div class="line">   <a class="code" href="group__transform.html#ga7996624886b3d2bffe59f55fbbb81668">bolt::cl::transform</a>(x.begin(), x.end(), y.begin(), z.begin(), s);</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> requires only a small syntax change, compared to the original <a class="el" href="OpenCLCodeStrings_Page.html#saxpy_stl">Saxpy implementation</a> - only the <a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> line before the class definition, passing the name of the class as a parameter, then the unmodified functor, and a trailing ");" at the end to close the macro. This can be useful for the relatively common operation of creating simple functors for use with algorthms. However, <a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> is based on a standard C-style #define macro; thus, it has important limitations: </p>
<ul>
<li><a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> only works with non-templated classes. To use a templated class with a Bolt algorithm call, see the <a class="el" href="OpenCLCodeStrings_Page.html#clCode_Templates">Templated Classes</a> section below on templated functors. </li>
<li><a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> uses macro stringification to create the OpenCL&trade; code string. As a result, the class definition has all line feeds removed and is compressed into a single line before being passed to the compiler. This can make debugging harder; thus, you may choose to use one of the other techniqueus described below.</li>
</ul>
<h2><a class="anchor" id="clCode_Traits"></a>
TypeName and ClCode Traits</h2>
<p>To create the OpenCL code string, the Bolt algorithm implementations must have access to the following information: </p>
<ul>
<li>The name of the functor (i.e., "SaxpyFunctor" in the examples above). </li>
<li>The class definition (i.e., the code that defines the SaxpyFunctor class).</li>
</ul>
<p>Bolt uses C++ traits to define both of these fields. A trait is a C++ coding technique that uses template specialization to allow the name (or code) to be associated with the class. Bolt code expects the <a class="el" href="structTypeName.html">TypeName</a> and <a class="el" href="structClCode.html">ClCode</a> traits to be defined for any functor that is passed to a Bolt API call.</p>
<h3><a class="anchor" id="TypeName"></a>
TypeName</h3>
<p>Bolt defines a baseline <a class="el" href="structTypeName.html">TypeName</a> trait that returns an error message. Each class to be used by Bolt must provide a template specialization for the <a class="el" href="structTypeName.html">TypeName</a> class that returns the string version of the class. For example: </p>
<div class="fragment"><div class="line">  <span class="comment">// Explicity create a TypeName trait for the example &#39;SaxpyFunctor&#39; class</span></div>
<div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="structTypeName.html">TypeName</a>&lt;SaxpyFunctor&gt; { <span class="keyword">static</span> std::string <span class="keyword">get</span>() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;SaxpyFunctor&quot;</span>; }};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use convenience function - this produces the same result as above.</span></div>
<div class="line">  <a class="code" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a>(SaxpyFunctor);</div>
</div><!-- fragment --><p>Because the template specialization syntax can be verbose, Bolt provides the convenience macro BOLT_CREATE_TYPENAME, as shown in the example above. Note that the class name used for BOLT_CREATE_TYPENAME (or the more verbose template specialization equivalent) must be fully instantiated without any template parameters. So: </p>
<ul>
<li><code><a class="el" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME(myplus&lt;T&gt;)</a></code> is illegal, but </li>
<li><code><a class="el" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME(myplus&lt;int&gt;)</a></code> is legal.</li>
</ul>
<h3><a class="anchor" id="ClCode"></a>
ClCode</h3>
<p>Bolt uses a similar technique to associate the string representation of the class with the class definition. In this case, the C++ trait is called "ClCode", and the default value is the empty string. Bolt defines a convenience function <a class="el" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a> to assist in creating <a class="el" href="structClCode.html">ClCode</a>. An example: </p>
<div class="fragment"><div class="line">  <a class="code" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a>(MyClass, <span class="stringliteral">&quot;class MyClass { ... };&quot;</span>);</div>
</div><!-- fragment --><p>Like the <a class="el" href="structTypeName.html">TypeName</a>, the <a class="el" href="structClCode.html">ClCode</a> trait can only be defined for fully instanted types without any template parameters.</p>
<h2><a class="anchor" id="clCode_ReadingFromFile"></a>
Reading functors from a file</h2>
<p>The <a class="el" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a> macro described in the previous section implicitly calls <a class="el" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a> and <a class="el" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a>, but you can also decide to explicitly call these. One case where this is useful is for complex functors where the code may be best organized in a separate file. The example below shows how to store the functor code in a file, then #include it (to create the host version), and use the Bolt calls to create the <a class="el" href="structClCode.html">ClCode</a> and <a class="el" href="structTypeName.html">TypeName</a> traits that the Bolt algorithm implementations look for.</p>
<p>This is the separate file "saxpy_functor.h": </p>
<div class="fragment"><div class="line"><span class="comment">// It contains the definition of the functor:</span></div>
<div class="line"><span class="keyword">struct </span>SaxpyFunctor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> _a;</div>
<div class="line">    SaxpyFunctor(<span class="keywordtype">float</span> a) : _a(a) {};</div>
<div class="line">    <span class="keywordtype">float</span> operator() (<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;xx, <span class="keyword">const</span> <span class="keywordtype">float</span> &amp;yy)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> _a * xx + yy;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is the .cpp file which loads the saxpy_functor.h code (Note that the header file must be available at run-time) : </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bolt_8h.html" title="Main public header file defining global functions for Bolt.">bolt/cl/bolt.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;bolt/cl/transform.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Make the SaxpyFunctor visible to the host compiler:</span></div>
<div class="line"><span class="preprocessor">#include &quot;saxpy_functor.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Read the header file into a string:</span></div>
<div class="line">std::string mycode = bolt::cl::fileToString(<span class="stringliteral">&quot;saxpy_functor.h&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Use the explicit Bolt macros to associate the typename and code with the SaxpyFunctor class:</span></div>
<div class="line"><a class="code" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a>(SaxpyFunctor);</div>
<div class="line"><a class="code" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a>(SaxpyFunctor, mycode);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Instantiate the class, and pass it to the Bolt function:</span></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">   SaxpyFunctor s(100);</div>
<div class="line"></div>
<div class="line">   std::vector&lt;float&gt; x(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; y(1000000); <span class="comment">// initialization not shown</span></div>
<div class="line">   std::vector&lt;float&gt; z(1000000);</div>
<div class="line">   </div>
<div class="line">   <a class="code" href="group__transform.html#ga7996624886b3d2bffe59f55fbbb81668">bolt::cl::transform</a>(x.begin(), x.end(), y.begin(), z.begin(), s);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="clCode_Templates"></a>
Templated Classes</h2>
<p>The BOLT_FUNCTOR, <a class="el" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a>, and <a class="el" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a> macros use C++ traits; thus, they require fully instantiated classes as parameters. Bolt, however, does support templated functors using techniques described in this section.</p>
<p><a class="el" href="group__ClCode.html#ga73fe90c6484b9cc8ac8e872723c7fbe3">BOLT_CODE_STRING</a> is a macro that expands to create a host-side version of the functor; it also returns a string that later can be manually associated with the class.</p>
<p>The last argument to every Bolt algorithm API call is an optional parameter <code>cl_code</code>, which contains a code string that is passed to the OpenCL compiler. The cl_code string is pre-prended to the code generated by Bolt, so cl_code can define classes or symbols that later are referenced by the functor. As seen in the following example, cl_code parameter is also useful in the case of templated functors.</p>
<div class="fragment"><div class="line"><span class="comment">// Example of defining a templated class that works with Bolt</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Save the code string in the InRange_CodeString var, </span></div>
<div class="line"><span class="comment">// and create a host-visible class definition :</span></div>
<div class="line">std::string InRange_CodeString = </div>
<div class="line"><a class="code" href="group__ClCode.html#ga73fe90c6484b9cc8ac8e872723c7fbe3">BOLT_CODE_STRING</a>(</div>
<div class="line">template&lt;typename T&gt;</div>
<div class="line"><span class="comment">// Functor for range checking.</span></div>
<div class="line"><span class="keyword">struct</span> InRange {</div>
<div class="line">    InRange (T low, T high) {</div>
<div class="line">        _low=low;</div>
<div class="line">        _high=high;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> T&amp; value) { <span class="keywordflow">return</span> (value &gt;= _low) &amp;&amp; (value &lt;= _high) ; };</div>
<div class="line"></div>
<div class="line">    T _low;</div>
<div class="line">    T _high;</div>
<div class="line">};</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Pass a fully instantiated class to BOLT_CREATE_TYPENAME:</span></div>
<div class="line"><a class="code" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a>(InRange&lt;float&gt;);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> testCountIf(<span class="keywordtype">int</span> aSize) </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize the A[] array:</span></div>
<div class="line">    std::vector&lt;float&gt; A(aSize);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; aSize; i++) {</div>
<div class="line">        A[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span> (i+1);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Count the number of elements from 7..15:</span></div>
<div class="line">    <span class="comment">// Note the last parameter passed in is the InRange_CodeString we defined above,</span></div>
<div class="line">    <span class="comment">// InRange_CodeString contains the definition of the templated InRange class</span></div>
<div class="line">    <span class="keywordtype">int</span> count7to15 = <a class="code" href="group__counting.html#ga5b0964aa8f2835f9d21ecc4e067f2294">bolt::cl::count_if</a> (A.begin(), A.end(), InRange&lt;float&gt;(7.0,15.0), InRange_CodeString);</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="functorLanguage"></a>
Functor Language</h1>
<p>The functor must be able to be compiled on both the host (C++) and device (OpenCL&trade; compilers. Thus, it must use only language constructs available in both of those languages. OpenCL&trade; is an "extended subset" of C99: the extensions include new built-in functions, as well as new types (i.e., vector types such as float4). In general, none of the OpenCL extensions can be used in Bolt functor definitions. Developers can work around this restriction by providing host-side functions with the same calling signature and functionality as OpenCL&trade; built-ins. Many of the OpenCL&trade; built-ins already have equivalent host code definitions in &lt;math.h&gt; (i.e., sin, cos, exp, log, pow, ceil, fabs, etc.). If host-side versions are provided, the host code compiles and links correctly using the host code definition, while the OpenCL&trade; code compiles correcly using the OpenCL&trade; built-in.</p>
<p>For more information, see : </p>
<ul>
<li>The Khronos OpenCL Specification: <a href="http://www.khronos.org/opencl/">http://www.khronos.org/opencl/</a> </li>
<li>The OpenCL Static C++ Kernel Language Extenstion : <a href="http://developer.amd.com/Assets/CPP_kernel_language.pdf">http://developer.amd.com/Assets/CPP_kernel_language.pdf</a></li>
</ul>
<h2><a class="anchor" id="different_code"></a>
Different Host and Device Code</h2>
<p>In most cases, developers want to generate both host and device code versions from a single source code, since this is easier to maintain and less prone to error. However, in some cases (such as when using a built-in function or type which is only available in OpenCL, or when providing device-specific optimization), developers may want to generate different code for the two compilers.</p>
<p>The memory layout of the functor must be the same between host and device. It is strongly recommended that the functor header be defined in a single location, using the <a class="el" href="OpenCLCodeStrings_Page.html#boltfunctormacro">BOLT_FUNCTOR macro</a> or technique described in <a class="el" href="OpenCLCodeStrings_Page.html#clCode_ReadingFromFile">Reading functors from a file</a> section. However, users can define separate implementations for the functor operator() methods: one made available to the host compiler, and one to the OpenCL compiler using the <code>cl_code</code> parameter.</p>
<h1><a class="anchor" id="Conclusion"></a>
Conclusion</h1>
<p>Bolt requires that the functor definition be available to both the host compiler and the device compiler. This page described several macros and techniques to help bridge that gap. We summarize and close with these recommendations:</p>
<ul>
<li>When the functor is relatively small and is best expressed inline with other sources, use the <a class="el" href="OpenCLCodeStrings_Page.html#boltfunctormacro">BOLT_FUNCTOR macro</a> The BOLT_FUNCTOR wraps the functor definition with only two lines of code, and automatically makes the code available to the OpenCL compiler. </li>
<li>When the functor is more complex and is best expressed in a separate file, or to improve the ability to debug by eliminating code compression into a single line, place the code in a separate file, as described in <a class="el" href="OpenCLCodeStrings_Page.html#clCode_ReadingFromFile">Reading functors from a file</a>. </li>
<li>For templated classes, use the technique described in <a class="el" href="OpenCLCodeStrings_Page.html#clCode_Templates">Templated Classes</a>.</li>
</ul>
<p>This section also described how Bolt uses C++ traits, including the <a class="el" href="group__ClCode.html#ga9684fd18d1ec87860561f58366d58fe0">BOLT_CREATE_TYPENAME</a> and <a class="el" href="group__ClCode.html#gaaa99aa35e6f6d1bdd3515c2eef9fb3ed">BOLT_CREATE_CLCODE</a> macros for low-level control (see <a class="el" href="OpenCLCodeStrings_Page.html#clCode_Traits">TypeName and ClCode Traits</a> section). Finally, the cl_code parameter is the optional last argument for every Bolt function; it can be used to pre-pend any code string to the code that is passed to the OpenCL&trade; compiler. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 14 2012 14:12:49 for Bolt Preview by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
